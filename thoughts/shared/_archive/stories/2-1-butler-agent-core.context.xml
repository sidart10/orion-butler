<?xml version="1.0" encoding="UTF-8"?>
<story-context id="2-1-butler-agent-core" epic="2">
  <metadata>
    <created>2026-01-15T16:00:00Z</created>
    <status>ready-for-dev</status>
    <priority>P0</priority>
    <risk>HIGH</risk>
  </metadata>

  <story>
    <overview>
      As a user, I want a main orchestrator agent that understands my requests,
      so that complex tasks are handled intelligently without manual coordination.

      The Butler Agent is the core orchestrator - the "front desk" of Orion that:
      - Receives all user messages
      - Classifies intent to determine handling approach
      - Maintains conversation context across turns
      - Delegates to specialist agents when needed
      - Synthesizes multi-step task results
    </overview>

    <acceptance-criteria>
      <criterion id="1" title="Intent Analysis and Delegation Decision">
        Given I send a message to Orion
        When the Butler Agent receives it
        Then it analyzes intent and determines if it can handle directly or needs to delegate
        And it maintains conversation context across turns
        And it has access to the full tool catalog

        Specifics:
        - Butler loads and uses system prompt from template
        - Intent classification returns one of: direct_answer, delegate_triage, delegate_schedule,
          delegate_draft, delegate_search, delegate_learn, clarify, cannot_help
        - Confidence score (0.0-1.0) accompanies each classification
        - Conversation history is preserved across turns
      </criterion>

      <criterion id="2" title="Multi-Step Task Coordination">
        Given a task requires multiple steps
        When the Butler Agent processes it
        Then it breaks down the task into sub-tasks
        And it coordinates execution in logical order
        And it synthesizes results into a coherent response

        Specifics:
        - Butler can spawn sub-agents (Triage, Scheduler, Communicator, Navigator, Preference Learner)
        - Context is passed to sub-agents correctly
        - Results from sub-agents are aggregated into final response
        - User sees coherent, synthesized output
      </criterion>
    </acceptance-criteria>

    <dependencies>
      <upstream title="Must be done first">
        <dependency>Story 1-5 (Agent Server Process) - Provides the Node.js server where Butler runs</dependency>
        <dependency>Story 1-7 (Claude Integration) - Provides Claude API client setup</dependency>
        <dependency>Test Infrastructure (C-001) - Agent schemas must exist before tests can be written</dependency>
      </upstream>
      <downstream title="Blocked by this story">
        <dependency>Story 2.2 (Agent Prompt Templates) - Will use Butler template as reference</dependency>
        <dependency>Story 2.3 (Sub-Agent Spawning) - Depends on Butler's delegation mechanism</dependency>
        <dependency>Stories 2.5-2.9 (Specialist Agents) - All spawned by Butler</dependency>
      </downstream>
    </dependencies>

    <technical-notes>
      <note category="critical-constraints">
        1. No auto-execution of write/destructive tools - Butler must delegate to permission system (Story 2.4)
        2. Maintain conversation history - Required for multi-turn interactions
        3. Schema validation on all outputs - Use Zod .safeParse() to handle malformed responses
        4. Graceful degradation - If Claude fails, return error state, don't crash
      </note>

      <note category="api-endpoints">
        Butler agent is accessed via:
        - Agent Server: localhost:3001
        - Streaming endpoint: GET /api/stream/:streamId?prompt=...&amp;sessionId=...
        - Response format: Server-Sent Events (SSE)
      </note>

      <note category="mock-strategy">
        All Claude responses MOCKED in unit/integration tests.
        Use BUTLER_MOCKS from tests/mocks/agents/butler.ts.
        Real Claude calls only in smoke tests (skipped by default).
        Schema validation ensures mock fidelity.
      </note>
    </technical-notes>
  </story>

  <tasks>
    <task id="1" title="Create Butler Agent Class Structure" ac-ref="1">
      <subtask>1.1 Create agent-server/src/agents/butler/index.ts - main agent class</subtask>
      <subtask>1.2 Create agent-server/src/agents/butler/types.ts - TypeScript interfaces</subtask>
      <subtask>1.3 Implement classifyIntent() method with Claude API call</subtask>
      <subtask>1.4 Implement handleMessage() main entry point</subtask>
      <subtask>1.5 Add conversation history tracking (in-memory for session)</subtask>
    </task>

    <task id="2" title="Implement Intent Classification Schema" ac-ref="1">
      <subtask>2.1 Create src/agents/schemas/butler.ts with Zod schemas</subtask>
      <subtask>2.2 Add schema validation to classifyIntent() response</subtask>
      <subtask>2.3 Handle schema validation errors gracefully</subtask>
    </task>

    <task id="3" title="Create Butler Prompt Template" ac-ref="1">
      <subtask>3.1 Create .claude/agents/butler.md prompt template</subtask>
      <subtask>3.2 Include persona, constraints, intent classification instructions</subtask>
      <subtask>3.3 Add tool catalog reference section</subtask>
      <subtask>3.4 Implement variable interpolation ({{user_name}}, {{current_date}}, etc.)</subtask>
    </task>

    <task id="4" title="Implement Sub-Agent Spawning" ac-ref="2">
      <subtask>4.1 Create agent-server/src/agents/orchestrator.ts for agent management</subtask>
      <subtask>4.2 Implement spawnSubAgent(agentType, context) method</subtask>
      <subtask>4.3 Add delegation context builder (relevantEntities, timeConstraints, etc.)</subtask>
      <subtask>4.4 Implement result aggregation from sub-agents</subtask>
    </task>

    <task id="5" title="Implement Tool Catalog Access" ac-ref="1">
      <subtask>5.1 Create agent-server/src/agents/tools/catalog.ts - tool registry</subtask>
      <subtask>5.2 Define tool interfaces for all available tools</subtask>
      <subtask>5.3 Wire Butler to tool catalog for capability awareness</subtask>
    </task>

    <task id="6" title="Write Tests" ac-ref="1,2">
      <subtask>6.1 Unit test: Prompt template loads correctly (test 2.1.1)</subtask>
      <subtask>6.2 Integration test: Simple query end-to-end (test 2.1.2)</subtask>
      <subtask>6.3 Integration test: Delegates to Triage for inbox (test 2.1.3)</subtask>
      <subtask>6.4 Integration test: Delegates to Scheduler for calendar (test 2.1.4)</subtask>
      <subtask>6.5 Unit test: Intent classification - greeting (test 2.1.5)</subtask>
      <subtask>6.6 Unit test: Intent classification - triage (test 2.1.6)</subtask>
      <subtask>6.7 Unit test: Intent classification - schedule (test 2.1.7)</subtask>
      <subtask>6.8 E2E test: Multi-step task synthesized (test 2.1.8)</subtask>
    </task>
  </tasks>

  <tests>
    <atdd-checklist-ref>atdd-checklist-2-1-butler-agent-core.md</atdd-checklist-ref>
    <test-summary>
      <total-tests>22</total-tests>
      <by-type>
        <happy-path>8</happy-path>
        <edge-cases>8</edge-cases>
        <error-handling>6</error-handling>
      </by-type>
    </test-summary>

    <test-file-locations>
      <file path="tests/unit/story-2.1-butler-agent.spec.ts" types="Unit tests: 2.1.1, 2.1.5, 2.1.6, 2.1.7, EC, EH, BC, SV"/>
      <file path="tests/integration/story-2.1-butler-delegation.spec.ts" types="Integration tests: 2.1.2, 2.1.3, 2.1.4, MS.EC, MS.EH"/>
      <file path="tests/e2e/story-2.1-multi-step.spec.ts" types="E2E test: 2.1.8"/>
      <file path="tests/mocks/agents/butler.ts" types="BUTLER_MOCKS"/>
    </test-file-locations>

    <quality-gates>
      <gate>All 22 tests passing</gate>
      <gate>Schema validation 100% coverage</gate>
      <gate>Mock scenarios match production schema</gate>
      <gate>Unit test coverage >= 80%</gate>
      <gate>Integration tests use mocks (no real Claude calls)</gate>
      <gate>E2E test passes in CI pipeline</gate>
      <gate>No P0/P1 bugs open</gate>
    </quality-gates>
  </tests>

  <architecture>
    <relevant-sections>
      <section title="Agent Hierarchy (6.1)">
        Butler Agent (Main Orchestrator)
            |
            +-- Triage Agent (Inbox processing)
            +-- Scheduler Agent (Calendar management)
            +-- Communicator Agent (Email/message drafting)
            +-- Navigator Agent (PARA search)
            +-- Preference Learner Agent (Pattern detection)
      </section>

      <section title="Agent Lifecycle States (6.2)">
        AgentState enum:
        - IDLE: Agent not processing
        - INITIALIZING: Starting up
        - LOADING_CONTEXT: Fetching relevant data
        - PROCESSING: Actively working on request
        - WAITING_FOR_TOOL: Tool execution in progress
        - WAITING_FOR_USER: Needs user input
        - DELEGATING: Spawning sub-agent
        - COMPLETING: Wrapping up response
        - ERROR: Something went wrong
      </section>

      <section title="AgentContext Interface (6.2)">
        interface AgentContext {
          sessionId: string;
          userId: string;
          activeProject?: Project;
          relevantContacts?: Contact[];
          userPreferences?: Preference[];
          recentContext?: Message[];
          currentState: AgentState;
        }
      </section>

      <section title="Prompt Caching (6.7)">
        - Minimum cacheable: 1,024 tokens
        - Static prompts should have cache_control marker
        - DO NOT cache dynamic content (user context, recent messages)

        Implementation pattern:
        system: [
          {
            type: 'text',
            text: BUTLER_SYSTEM_PROMPT,  // ~2000 tokens
            cache_control: { type: 'ephemeral' },  // Cache for 5 min
          },
        ]
      </section>
    </relevant-sections>

    <patterns-to-follow>
      <pattern name="Zod Schema Validation">
        All agent responses must be validated against Zod schemas.
        Use .safeParse() to handle malformed responses gracefully.
        Log validation errors for debugging.
      </pattern>

      <pattern name="Claude Agent SDK Integration">
        import { ClaudeAgentOptions } from '@anthropic-ai/claude-agent-sdk';

        export const agentConfig: ClaudeAgentOptions = {
          model: 'claude-sonnet-4-5',
          // ... tools
        };
      </pattern>

      <pattern name="Mock Structure for Testing">
        export const BUTLER_MOCKS = {
          direct_greeting: {
            classification: {
              intent: 'direct_answer',
              confidence: 0.95,
              reasoning: 'Simple greeting, no delegation needed'
            },
            response: 'Hello! How can I help you today?'
          },
          delegate_to_triage: { ... },
          delegate_to_scheduler: { ... }
        };
      </pattern>
    </patterns-to-follow>

    <file-structure>
      <directory path="agent-server/src/agents/">
        <file>butler/index.ts - Main Butler agent class</file>
        <file>butler/types.ts - TypeScript interfaces</file>
        <file>butler/prompts.ts - Prompt template loading</file>
        <file>orchestrator.ts - Agent spawning/coordination</file>
        <file>lifecycle.ts - AgentState enum, AgentContext</file>
        <file>tools/catalog.ts - Tool registry</file>
      </directory>
      <directory path="src/agents/schemas/">
        <file>butler.ts - Zod schemas (IntentClassificationSchema, ButlerResponseSchema)</file>
        <file>index.ts - Schema exports</file>
      </directory>
      <directory path=".claude/agents/">
        <file>butler.md - Butler prompt template</file>
      </directory>
      <directory path="tests/">
        <file>unit/story-2.1-butler-agent.spec.ts</file>
        <file>integration/story-2.1-butler-delegation.spec.ts</file>
        <file>e2e/story-2.1-multi-step.spec.ts</file>
        <file>mocks/agents/butler.ts - Mock responses</file>
      </directory>
    </file-structure>
  </architecture>

  <schemas>
    <schema name="IntentClassificationSchema">
      import { z } from 'zod';

      export const IntentClassificationSchema = z.object({
        intent: z.enum([
          'direct_answer',      // Butler handles directly
          'delegate_triage',    // Route to Triage Agent
          'delegate_schedule',  // Route to Scheduler Agent
          'delegate_draft',     // Route to Communicator Agent
          'delegate_search',    // Route to Navigator Agent
          'delegate_learn',     // Route to Preference Learner
          'clarify',           // Need more info from user
          'cannot_help'        // Outside capabilities
        ]),
        confidence: z.number().min(0).max(1),
        reasoning: z.string(),
        delegationContext: z.object({
          relevantEntities: z.array(z.string()).optional(),
          timeConstraints: z.string().optional(),
          userPreferences: z.array(z.string()).optional()
        }).optional()
      });
    </schema>

    <schema name="ButlerResponseSchema">
      export const ButlerResponseSchema = z.object({
        classification: IntentClassificationSchema,
        response: z.string().optional(),          // If direct_answer
        delegatedAgent: z.string().optional(),    // If delegate_*
        followUpQuestions: z.array(z.string()).optional()
      });
    </schema>
  </schemas>

  <mock-scenarios>
    <scenario key="direct_greeting" intent="direct_answer" confidence="0.95" use-case="Simple greeting"/>
    <scenario key="delegate_to_triage" intent="delegate_triage" confidence="0.88" use-case="Inbox prioritization"/>
    <scenario key="delegate_to_scheduler" intent="delegate_schedule" confidence="0.92" use-case="Meeting scheduling"/>
    <scenario key="delegate_to_draft" intent="delegate_draft" confidence="0.85" use-case="Email composition"/>
    <scenario key="needs_clarification" intent="clarify" confidence="0.40" use-case="Ambiguous request"/>
    <scenario key="out_of_scope" intent="cannot_help" confidence="0.90" use-case="Outside capabilities"/>
  </mock-scenarios>

  <references>
    <ref doc="architecture.md" sections="6.1-6.4, 6.7">Agent hierarchy, lifecycle, context, prompt caching</ref>
    <ref doc="test-infra-agent-schemas.md" sections="2.1">Zod schemas and mock structure</ref>
    <ref doc="test-design-epic-2.md" sections="Story 2.1">Test scenarios and code examples</ref>
    <ref doc="epics.md" sections="Story 2.1">User story and acceptance criteria</ref>
  </references>
</story-context>
