"""Headless Claude CLI spawning with depth control and routing.

Spawns Claude agents via `claude -p` command with:
- Depth limit enforcement (max 3 levels)
- Environment variable propagation
- Deterministic agent routing
- CoordinationDB registration
"""

import os
import re
import subprocess
import uuid
from dataclasses import dataclass, field
from typing import Any

import psutil


class DepthLimitExceeded(Exception):
    """Raised when spawn depth exceeds maximum allowed."""
    pass


@dataclass
class SpawnedAgent:
    """Record of a spawned Claude agent."""
    pid: int
    agent_id: str
    output_file: str
    depth_level: int
    pattern: str | None = None
    premise: str | None = None


# Max depth before hard rejection
MAX_DEPTH = 3

# Agent routing table: keyword patterns -> agent name
AGENT_ROUTING = {
    # Orchestrate (check first - high priority)
    r'\b(coordinate|orchestrate|multi-agent)\b': 'maestro',

    # Implement
    r'\b(implement|build|create)\b.*\b(feature|system|module)\b': 'kraken',
    r'\b(fix|tweak|update|small)\b': 'spark',

    # Document
    r'\b(document|handoff|summarize|ledger)\b': 'scribe',

    # Debug
    r'\b(security|vulnerability|CVE|audit)\b': 'aegis',
    r'\b(performance|memory|slow|race|profile)\b': 'profiler',
    r'\b(debug|investigate|error|bug|crash)\b': 'sleuth',

    # Validate
    r'\b(e2e|end-to-end|acceptance)\b': 'atlas',
    r'\b(test|validate|verify|unit|integration)\b': 'arbiter',

    # Research
    r'\b(research|best practices|NIA|learn)\b': 'oracle',
    r'\b(analyze repo|external repo|github)\b': 'pathfinder',
    r'\b(find|locate|where|codebase)\b': 'scout',

    # Plan (check refactor first, then general plan)
    r'\b(refactor|migration|cleanup)\b': 'phoenix',
    r'\b(plan|design)\b.*\b(feature|dashboard|new|api|endpoint)\b': 'architect',

    # Review
    r'\b(review)\b.*\b(refactor|migration)\b': 'warden',
    r'\b(review)\b': 'sentinel',

    # Session/History
    r'\b(session|precedent|history|context)\b': 'chronicler',

    # Deploy
    r'\b(deploy|release|version|changelog)\b': 'herald',
}


def check_spawn_allowed() -> bool:
    """Check if spawning is allowed based on depth and resources.

    Returns:
        True if spawn is allowed, False otherwise.
    """
    depth = int(os.environ.get("DEPTH_LEVEL", "0"))

    # Hard depth limit
    if depth >= MAX_DEPTH:
        return False

    return True


def resources_available() -> bool:
    """Check if system resources are available for spawning.

    Returns:
        True if resources are available (CPU < 80%, memory < 85%).
    """
    try:
        cpu_percent = psutil.cpu_percent(interval=0.1)
        mem_percent = psutil.virtual_memory().percent

        return cpu_percent < 80 and mem_percent < 85
    except Exception:
        # If we can't check, assume available
        return True


def route_to_agent(prompt: str) -> str:
    """Route a prompt to the appropriate agent using keyword matching.

    Args:
        prompt: The task prompt to route.

    Returns:
        Agent name (kraken, spark, scribe, etc.)
    """
    prompt_lower = prompt.lower()

    # Try each pattern in order
    for pattern, agent in AGENT_ROUTING.items():
        if re.search(pattern, prompt_lower, re.IGNORECASE):
            return agent

    # Default fallback
    return "spark"


def spawn_agent(
    prompt: str,
    perspective: str = "",
    depth_level: int | None = None,
    allowed_tools: list[str] | None = None,
    pattern: str | None = None,
    agent_id: str | None = None,
) -> SpawnedAgent:
    """Spawn a headless Claude agent via `claude -p`.

    Args:
        prompt: The task prompt for the agent.
        perspective: Optional perspective prefix (e.g., "Security expert").
        depth_level: Override depth level (defaults to env var + 1).
        allowed_tools: List of tools to allow (e.g., ["Read", "Grep"]).
        pattern: Coordination pattern (swarm, hierarchical, etc.).
        agent_id: Override agent ID (defaults to UUID).

    Returns:
        SpawnedAgent with process info and tracking data.

    Raises:
        DepthLimitExceeded: If spawn would exceed max depth.
    """
    # Get current depth from environment
    current_depth = int(os.environ.get("DEPTH_LEVEL", "0"))

    if depth_level is None:
        depth_level = current_depth

    # Check depth limit
    if depth_level >= MAX_DEPTH:
        raise DepthLimitExceeded(f"Max nesting depth ({MAX_DEPTH}) reached")

    # Generate agent ID if not provided
    if agent_id is None:
        agent_id = str(uuid.uuid4())

    # Create output directory
    output_dir = "/tmp/claude-agents"
    os.makedirs(output_dir, exist_ok=True)
    output_file = os.path.join(output_dir, f"{agent_id}.json")

    # Build command
    full_prompt = f"{perspective}: {prompt}" if perspective else prompt
    cmd = [
        "claude", "-p", full_prompt,
        "--output-format", "json",
    ]

    if allowed_tools:
        cmd.extend(["--allowedTools", ",".join(allowed_tools)])

    # Build environment
    env = os.environ.copy()
    env.update({
        "DEPTH_LEVEL": str(depth_level + 1),
        "PARENT_AGENT_ID": os.environ.get("AGENT_ID", "orchestrator"),
        "AGENT_ID": agent_id,
        "SESSION_ID": os.environ.get("SESSION_ID", "default"),
    })

    if pattern:
        env["PATTERN_TYPE"] = pattern

    # Spawn process
    with open(output_file, 'w') as f:
        proc = subprocess.Popen(
            cmd,
            stdout=f,
            stderr=subprocess.DEVNULL,
            env=env,
        )

    # Register in database (async version would use CoordinationDBPg)
    register_agent_in_db(
        agent_id=agent_id,
        session_id=env["SESSION_ID"],
        pid=proc.pid,
        parent=env["PARENT_AGENT_ID"],
        pattern=pattern,
        premise=perspective or None,
        depth_level=depth_level + 1,
    )

    return SpawnedAgent(
        pid=proc.pid,
        agent_id=agent_id,
        output_file=output_file,
        depth_level=depth_level + 1,
        pattern=pattern,
        premise=perspective,
    )


def register_agent_in_db(
    agent_id: str,
    session_id: str,
    pid: int,
    parent: str,
    pattern: str | None = None,
    premise: str | None = None,
    depth_level: int = 1,
) -> None:
    """Register agent in CoordinationDB (sync wrapper).

    In production, this would call CoordinationDBPg.register_agent().
    For now, we write to a local tracking file as fallback.

    Args:
        agent_id: Unique agent identifier.
        session_id: Session this agent belongs to.
        pid: Process ID.
        parent: Parent agent ID.
        pattern: Coordination pattern.
        premise: Agent premise/perspective.
        depth_level: Nesting depth.
    """
    import json
    from datetime import UTC, datetime

    # Try PostgreSQL first
    try:
        import asyncio

        from scripts.agentica_patterns.coordination_pg import CoordinationDBPg

        async def _register():
            async with CoordinationDBPg() as db:
                await db.register_agent(
                    agent_id=agent_id,
                    session_id=session_id,
                    pid=pid,
                    parent_agent_id=parent if parent != "orchestrator" else None,
                    pattern=pattern,
                    premise=premise,
                    depth_level=depth_level,
                )

        asyncio.run(_register())
        return
    except Exception:
        pass  # Fall back to file-based tracking

    # Fallback: write to tracking file
    tracking_file = "/tmp/claude-agents/registry.jsonl"
    os.makedirs(os.path.dirname(tracking_file), exist_ok=True)

    record = {
        "agent_id": agent_id,
        "session_id": session_id,
        "pid": pid,
        "parent_agent_id": parent,
        "pattern": pattern,
        "premise": premise,
        "depth_level": depth_level,
        "spawned_at": datetime.now(UTC).isoformat(),
        "status": "running",
    }

    with open(tracking_file, "a") as f:
        f.write(json.dumps(record) + "\n")


# Lead agents that can spawn other agents
LEAD_AGENTS = {"kraken", "architect", "phoenix", "herald", "maestro"}

# Worker agents (leaf nodes, no spawning)
WORKER_AGENTS = {
    "spark", "scribe", "sleuth", "aegis", "profiler",
    "arbiter", "atlas", "oracle", "scout", "pathfinder",
    "sentinel", "warden", "chronicler",
}


def is_lead_agent(agent_name: str) -> bool:
    """Check if an agent is a Lead (can spawn others).

    Args:
        agent_name: Name of the agent.

    Returns:
        True if the agent is a Lead.
    """
    return agent_name.lower() in LEAD_AGENTS


def is_worker_agent(agent_name: str) -> bool:
    """Check if an agent is a Worker (leaf node).

    Args:
        agent_name: Name of the agent.

    Returns:
        True if the agent is a Worker.
    """
    return agent_name.lower() in WORKER_AGENTS
